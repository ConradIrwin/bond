<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Bond 0.2.2 Documentation</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html" title="Index">Index</a> &raquo; 
    <span class="title">File: README</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><div id='filecontents'><p>
Note: To read a linked version of this README, <a
href="http://tagaholic.me/bond/doc/">click here</a>
</p>
<h2>Description</h2>
<p>
Bond is on a mission to improve irb&#8217;s autocompletion. Aside from
doing everything irb&#8217;s can do and fixing its quirks, Bond can
autocomplete argument(s) to methods, uniquely completing per module, per
method and per argument. Bond brings irb&#8217;s completion closer to
bash/zsh as it provides a configuration system and a DSL for creating
custom completions and completion rules. With this configuration system,
users can customize their irb autocompletions and share it with others.
Bond can also generate completions from yard documentation and load
completions that ship with gems. Bond is able to offer more than
irb&#8217;s completion since it uses a Readline C extension to get the full
line of input when completing as opposed to irb&#8217;s last-word approach.
</p>
<h2>Install</h2>
<p>
Install the gem with:
</p>
<pre class="code">
    <span class='sudo identifier id'>sudo</span> <span class='gem identifier id'>gem</span> <span class='install identifier id'>install</span> <span class='bond identifier id'>bond</span>
</pre>
<h2>Setup</h2>
<p>
To start off, replace irb&#8217;s completion (require
&#8216;irb/completion&#8217;) with Bond&#8217;s enhanced version in your
irbrc :
</p>
<pre class="code">
  <span class='require identifier id'>require</span> <span class='string val'>'bond'</span>
  <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='start identifier id'>start</span>
</pre>
<p>
This gives you more consistent method completion on any object,
customizable completions and argument completion of some 80+ methods
including Hash#[], Kernel#system, Kernel#require and some Rails methods.
</p>
<h2>Method Argument Completion</h2>
<p>
By default, Bond autocompletes arguments for a number of core methods:
</p>
<pre class="code">
  $ <span class='irb identifier id'>irb</span>
  <span class='comment val'># require completes gems and anything in $LOAD_PATH</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='require identifier id'>require</span> <span class='string val'>'rb[TAB]
  rbconfig.rb          rbconfig/
  &gt;&gt; require '</span><span class='rbconfig identifier id'>rbconfig</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='require identifier id'>require</span> <span class='string val'>'rbconfig.rb'</span>

  <span class='comment val'># hash methods can complete their keys</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='CONFIG constant id'>CONFIG</span><span class='colon2 op'>::</span><span class='CONFIG constant id'>CONFIG</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='CONFIG constant id'>CONFIG</span><span class='colon2 op'>::</span><span class='CONFIG constant id'>CONFIG</span><span class='lbrack token'>[</span><span class='string val'>'m[TAB]
  &gt;&gt; CONFIG::CONFIG['</span><span class='mandir identifier id'>mandir</span><span class='string val'>'
  &gt;&gt; CONFIG::CONFIG['</span><span class='mandir identifier id'>mandir</span><span class='string val'>']

  &gt;&gt; ENV['</span><span class='CO constant id'>CO</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='COLUMNS constant id'>COLUMNS</span>       <span class='COMMAND_MODE constant id'>COMMAND_MODE</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='ENV constant id'>ENV</span><span class='lbrack token'>[</span><span class='string val'>'COL[TAB]
  &gt;&gt; ENV['</span><span class='COLUMNS constant id'>COLUMNS</span><span class='string val'>'
  &gt;&gt; ENV['</span><span class='COLUMNS constant id'>COLUMNS</span><span class='string val'>']

  # array methods can complete their elements
  &gt;&gt; %w{ab bc cd de}.delete '</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='ab identifier id'>ab</span>  <span class='bc identifier id'>bc</span>  <span class='cd identifier id'>cd</span>  <span class='de identifier id'>de</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='dstring node'>%w{ab  bc  cd  de}</span><span class='dot token'>.</span><span class='delete identifier id'>delete</span> <span class='string val'>'a[TAB]
  &gt;&gt; %w{ab  bc  cd  de}.delete '</span><span class='ab identifier id'>ab</span><span class='string val'>'

  # system can complete shell commands
  &gt;&gt; system '</span><span class='ec identifier id'>ec</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='system identifier id'>system</span> <span class='string val'>'echo
  &gt;&gt; system '</span><span class='echo identifier id'>echo</span><span class='string val'>'
</span></pre>
<p>
Bond also comes with some basic Rails completions, mostly for
attributes/columns of models:
</p>
<pre class="code">
  $ <span class='script identifier id'>script</span><span class='div op'>/</span><span class='console identifier id'>console</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='column_names identifier id'>column_names</span>
  <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='string val'>&quot;id&quot;</span><span class='comma token'>,</span> <span class='string val'>&quot;name&quot;</span><span class='comma token'>,</span> <span class='string val'>&quot;description&quot;</span><span class='comma token'>,</span> <span class='string val'>&quot;created_at&quot;</span><span class='comma token'>,</span> <span class='string val'>&quot;updated_at&quot;</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='create identifier id'>create</span> <span class='symbol val'>:n</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='create identifier id'>create</span> <span class='symbol val'>:name</span>
  <span class='dot3 op'>...</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='update_attribute identifier id'>update_attribute</span> <span class='symbol val'>:d</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='update_attribute identifier id'>update_attribute</span> <span class='symbol val'>:description</span>
  <span class='dot3 op'>...</span>
</pre>
<p>
To see more methods whose arguments can be completed:
</p>
<pre class="code">
  <span class='rshft op'>&gt;&gt;</span> <span class='puts identifier id'>puts</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='list_methods identifier id'>list_methods</span>
  <span class='ActiveRecord constant id'>ActiveRecord</span><span class='colon2 op'>::</span><span class='Base constant id'>Base</span><span class='comment val'>#[]</span>
  <span class='ActiveRecord constant id'>ActiveRecord</span><span class='colon2 op'>::</span><span class='Base constant id'>Base</span><span class='comment val'>#attribute_for_inspect</span>
  <span class='dot3 op'>...</span>
</pre>
<h2>Multiple Arguments</h2>
<p>
Every time a comma appears after a method, Bond starts a new completion.
This allows a method to complete multiple arguments. <b>Each</b> argument
can be have a unique set of completions since a completion action is aware
of what argument it is currently completing. Take for example the
completion for Object#send:
</p>
<pre class="code">
  <span class='rshft op'>&gt;&gt;</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='symbol val'>:me</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='symbol val'>:method</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='symbol val'>:method</span><span class='comma token'>,</span> <span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='agent identifier id'>agent</span>       <span class='complete identifier id'>complete</span>    <span class='config identifier id'>config</span>      <span class='recomplete identifier id'>recomplete</span>  <span class='spy identifier id'>spy</span>         <span class='start identifier id'>start</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='symbol val'>:method</span><span class='comma token'>,</span> <span class='symbol val'>:a</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='symbol val'>:method</span><span class='comma token'>,</span> <span class='symbol val'>:agent</span>
  <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='comment val'>#&lt;Method: Module#agent&gt;</span>
</pre>
<p>
Notice the arguments were completed differently: the first completing for
Bond.send and the second for Bond.method. The second argument was only able
to complete because there&#8217;s a completion for Module#method. Using
Object#send it&#8217;s possible to use completions defined for private
methods i.e. Module#remove_const:
</p>
<pre class="code">
  <span class='rshft op'>&gt;&gt;</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='symbol val'>:remove_const</span><span class='comma token'>,</span> <span class='symbol val'>:A</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='symbol val'>:Agent</span>            <span class='symbol val'>:AnywhereMission</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='symbol val'>:remove_const</span><span class='comma token'>,</span> <span class='symbol val'>:Ag</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Bond constant id'>Bond</span><span class='dot token'>.</span><span class='send identifier id'>send</span> <span class='symbol val'>:remove_const</span><span class='comma token'>,</span> <span class='symbol val'>:Agent</span>
</pre>
<p>
Since Bond uses a comma to delimit completions, methods whose last argument
is a hash can have their hash keys autocompleted. Revisiting the above
Rails example:
</p>
<pre class="code">
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='create identifier id'>create</span> <span class='symbol val'>:n</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='create identifier id'>create</span> <span class='symbol val'>:name</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='create identifier id'>create</span> <span class='symbol val'>:name=</span><span class='gt op'>&gt;</span><span class='string val'>'example.com'</span><span class='comma token'>,</span> <span class='symbol val'>:d</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='create identifier id'>create</span> <span class='symbol val'>:name=</span><span class='gt op'>&gt;</span><span class='string val'>'example.com'</span><span class='comma token'>,</span> <span class='symbol val'>:description</span>
  <span class='dot3 op'>...</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='update_attributes identifier id'>update_attributes</span> <span class='symbol val'>:d</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='update_attributes identifier id'>update_attributes</span> <span class='symbol val'>:description</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='update_attributes identifier id'>update_attributes</span> <span class='symbol val'>:description=</span><span class='gt op'>&gt;</span><span class='string val'>'zzz'</span><span class='comma token'>,</span> <span class='symbol val'>:u</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='Url constant id'>Url</span><span class='dot token'>.</span><span class='first identifier id'>first</span><span class='dot token'>.</span><span class='update_attributes identifier id'>update_attributes</span> <span class='symbol val'>:description=</span><span class='gt op'>&gt;</span><span class='string val'>'zzz'</span><span class='comma token'>,</span> <span class='symbol val'>:updated_at</span>
  <span class='dot3 op'>...</span>
</pre>
<h2>Creating Completions</h2>
<p>
Bond&#8217;s completion resembles bash/zsh&#8217;s. When Bond.start is
called, Bond looks up completion files in multiple places: ~/.bondrc and
~/.bond/completions/*.rb. Here&#8217;s how bash and bond completion
definitions compare in their config files:
</p>
<pre class="code">
  <span class='comment val'># Bash</span>
  <span class='complete identifier id'>complete</span> <span class='minus op'>-</span><span class='W constant id'>W</span> <span class='string val'>&quot;one two three&quot;</span> <span class='example identifier id'>example</span>
  <span class='complete identifier id'>complete</span> <span class='minus op'>-</span><span class='F constant id'>F</span> <span class='_example identifier id'>_example</span> <span class='example identifier id'>example</span>

  <span class='comment val'># Bond</span>
  <span class='complete identifier id'>complete</span><span class='lparen token'>(</span><span class='symbol val'>:method=</span><span class='gt op'>&gt;</span><span class='string val'>'example'</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span> <span class='dstring node'>%w{one two three}</span> <span class='rbrace token'>}</span>
  <span class='complete identifier id'>complete</span><span class='lparen token'>(</span><span class='symbol val'>:method=</span><span class='gt op'>&gt;</span><span class='string val'>'example'</span><span class='comma token'>,</span> <span class='symbol val'>:action=</span><span class='gt op'>&gt;</span><span class='string val'>'_example'</span><span class='rparen token'>)</span>
</pre>
<p>
To read up on the wealth of completion types one can make, see the docs for
Bond.complete.
</p>
<h3>Creating Argument Completions for Methods</h3>
<p>
While the above method completion was a static list, most completions will
dynamically generate completions based on the method&#8217;s receiver
(object). Let&#8217;s look at such an example with Hash#[] :
</p>
<pre class="code">
  <span class='complete identifier id'>complete</span><span class='lparen token'>(</span><span class='symbol val'>:method=</span><span class='gt op'>&gt;</span><span class='string val'>&quot;Hash#[]&quot;</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='e identifier id'>e</span><span class='bitor op'>|</span> <span class='e identifier id'>e</span><span class='dot token'>.</span><span class='object identifier id'>object</span><span class='dot token'>.</span><span class='keys identifier id'>keys</span> <span class='rbrace token'>}</span>
</pre>
<p>
As you can see, the currently typed object is available as the :object
attribute of the block&#8217;s argument, a Bond::Input object. This object
can offer other useful attributes describing what the user has typed. For
example, the :argument attribute holds the current argument number being
completed. Here&#8217;s a completion that uses this attribute to complete
differently for the first argument and remaining arguments:
</p>
<pre class="code">
   <span class='complete identifier id'>complete</span><span class='lparen token'>(</span><span class='symbol val'>:method=</span><span class='gt op'>&gt;</span><span class='string val'>'example'</span><span class='rparen token'>)</span> <span class='lbrace token'>{</span><span class='bitor op'>|</span><span class='e identifier id'>e</span><span class='bitor op'>|</span> <span class='e identifier id'>e</span><span class='dot token'>.</span><span class='argument identifier id'>argument</span> <span class='gt op'>&gt;</span> <span class='integer val'>1</span> <span class='question op'>?</span> <span class='dstring node'>%w{verbose force noop}</span> <span class='colon op'>:</span> <span class='dstring node'>%w{one two three}</span> <span class='rbrace token'>}</span>
</pre>
<h3>Creating Other Completions</h3>
<p>
First you should know Bond works: A user creates completion missions with
Bond.start and its config files (which are just Bond.complete calls). When
a user autocompletes, Bond.agent looks up missions in the <b>order</b> they
were defined and completes with the first one that matches. The exception
to this ordering are :method completions.
</p>
<p>
To create a completion, Bond.complete needs a regexp to match the user
input and an action to generate completions when it matches. If the
completion isn&#8217;t working, use Bond.spy to see which completion is
executing. If a completion needs to be placed before existing completions,
use the :place option.
</p>
<h2>Irb&#8217;s Incorrect Completions</h2>
<p>
There are a number of incorrect completions irb gives for object methods.
Bond fixes all of the ones described below.
</p>
<p>
Irb completes anything surrounded with &#8217;{}&#8217; the same:
</p>
<pre class="code">
  <span class='rshft op'>&gt;&gt;</span> <span class='proc identifier id'>proc</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span><span class='dot token'>.</span><span class='c identifier id'>c</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='call identifier id'>call</span>     <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='class identifier id'>class</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='clear identifier id'>clear</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='clone identifier id'>clone</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='collect identifier id'>collect</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='dstring node'>%w{ab bc}</span><span class='dot token'>.</span><span class='c identifier id'>c</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='call identifier id'>call</span>     <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='class identifier id'>class</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='clear identifier id'>clear</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='clone identifier id'>clone</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='collect identifier id'>collect</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='regexp val'>%r{ab bc}</span><span class='dot token'>.</span><span class='c identifier id'>c</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='call identifier id'>call</span>     <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='class identifier id'>class</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='clear identifier id'>clear</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='clone identifier id'>clone</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='collect identifier id'>collect</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span><span class='dot token'>.</span><span class='c identifier id'>c</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='call identifier id'>call</span>     <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='class identifier id'>class</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='clear identifier id'>clear</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='clone identifier id'>clone</span>    <span class='rbrace token'>}</span><span class='dot token'>.</span><span class='collect identifier id'>collect</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='lbrace token'>{</span><span class='rbrace token'>}</span><span class='dot token'>.</span><span class='call identifier id'>call</span>
  <span class='NoMethodError constant id'>NoMethodError</span><span class='colon op'>:</span> <span class='undefined identifier id'>undefined</span> <span class='method identifier id'>method</span> <span class='xstring val'>`call' for {}:Hash
          from (irb):1
</span></pre>
<p>
There are a number of cases where irb gives a default completion because it
doesn&#8217;t know what else to do.
</p>
<pre class="code">
  <span class='comment val'># The default completion</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>

  <span class='comment val'># And all of these cases are apparently the same:</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='nil nil kw'>nil</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='false false kw'>false</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='true true kw'>true</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>
  <span class='comment val'># Regular expressions with spaces</span>
  <span class='rshft op'>&gt;&gt;</span> <span class='regexp val'>/man oh man/</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>
  <span class='comment val'># Grouped expressions</span>
 <span class='rshft op'>&gt;&gt;</span> <span class='lparen token'>(</span><span class='integer val'>3</span> <span class='plus op'>+</span> <span class='integer val'>4</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
 <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>

 <span class='comment val'># Nested hashes and arrays</span>
 <span class='rshft op'>&gt;&gt;</span> <span class='lbrace token'>{</span><span class='symbol val'>:a=</span><span class='gt op'>&gt;</span><span class='lbrace token'>{</span><span class='symbol val'>:a=</span><span class='gt op'>&gt;</span><span class='integer val'>1</span><span class='rbrace token'>}</span><span class='rbrace token'>}</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
 <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>
 <span class='rshft op'>&gt;&gt;</span> <span class='lbrack token'>[</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='lbrack token'>[</span><span class='integer val'>3</span><span class='comma token'>,</span><span class='integer val'>4</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
 <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>

 <span class='comment val'># Any object produced from a method call</span>
 <span class='rshft op'>&gt;&gt;</span> <span class='string val'>'awesome'</span><span class='dot token'>.</span><span class='to_sym identifier id'>to_sym</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
 <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>
 <span class='rshft op'>&gt;&gt;</span> <span class='symbol val'>:dude</span><span class='dot token'>.</span><span class='to_s identifier id'>to_s</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
 <span class='Display constant id'>Display</span> <span class='all identifier id'>all</span> <span class='integer val'>496</span> <span class='possibilities? fid id'>possibilities?</span> <span class='lparen token'>(</span><span class='y identifier id'>y</span> <span class='or or kw'>or</span> <span class='n identifier id'>n</span><span class='rparen token'>)</span>
 
</pre>
<p>
Ranges don&#8217;t get much love
</p>
<pre class="code">
  <span class='rshft op'>&gt;&gt;</span> <span class='lparen token'>(</span><span class='float val'>2</span><span class='dot2 op'>..</span><span class='integer val'>4</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='lbrack token'>[</span><span class='TAB constant id'>TAB</span><span class='rbrack token'>]</span>
  <span class='comment val'># Nothing happens</span>
</pre>
<h2>Limitations</h2>
<p>
If on a Mac and using Editline as a Readline replacement (Readline::VERSION
=~ /editline/i), Bond will probably not work consistently. I strongly
recommend switching to the official Readline. If using rvm, <a
href="http://niwos.com/2010/03/19/rvm-on-osx-snow-leopard-readline-errors/">this
post</a> has good instructions for reinstalling ruby with the official
Readline.
</p>
<h2>Credits</h2>
<ul>
<li><p>
Csaba Hank for <a
href="http://www.creo.hu/~csaba/ruby/irb-enhancements/doc/files/README.html">providing
the C extension</a> which Bond uses to read Readline&#8217;s full buffer.
</p>
</li>
<li><p>
Takao Kouji for <a
href="http://svn.ruby-lang.org/cgi-bin/viewvc.cgi/trunk/ext/readline/readline.c?view=diff&r1=24018&r2=24019">commiting</a>
this Readline enhancement to ruby 1.9.2.
</p>
</li>
<li><p>
pd for compatibility with emacs&#8217; inf-ruby mode.
</p>
</li>
<li><p>
timcharper for improving extconf.rb.
</p>
</li>
</ul>
<h2>Links</h2>
<ul>
<li><p>
<a
href="http://tagaholic.me/2010/05/07/screencast-of-argument-autocompletion-for-methods-in-irb.html">tagaholic.me/2010/05/07/screencast-of-argument-autocompletion-for-methods-in-irb.html</a>
</p>
</li>
<li><p>
<a
href="http://tagaholic.me/2009/07/16/bond-from-irb-with-completion-love.html">tagaholic.me/2009/07/16/bond-from-irb-with-completion-love.html</a>
</p>
</li>
<li><p>
<a
href="http://tagaholic.me/2009/07/22/better-irb-completion-with-bond.html">tagaholic.me/2009/07/22/better-irb-completion-with-bond.html</a>
</p>
</li>
<li><p>
<a
href="http://tagaholic.me/2009/07/23/mini-irb-and-mini-script-console.html">tagaholic.me/2009/07/23/mini-irb-and-mini-script-console.html</a>
</p>
</li>
</ul>
<h2>Todo</h2>
<ul>
<li><p>
Generate method autocompletions for any arguments based on yardoc
documentation.
</p>
</li>
<li><p>
Make completion actions more synonymous with argument types.
</p>
</li>
<li><p>
Cache expensive completion actions.
</p>
</li>
<li><p>
Ensure completions work when there is additional, unrelated text to the
right of a completion.
</p>
</li>
</ul>
</div></div>
    
    <div id="footer">
  Generated on Sat Jul 17 07:21:09 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool">yard</a>
  0.5.8 (ruby-1.8.7).
</div>

  </body>
</html>